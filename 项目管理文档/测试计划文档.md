# 团队知识库管理工具 - 测试计划文档 (macOS 11.7.10 Claude AI 自动测试)

## 1. 测试概述

### 1.1 测试环境信息
- **测试平台**: macOS 11.7.10 (Big Sur)
- **测试模式**: 单机测试 + Claude AI 自动测试
- **代码生成**: 通过 Claude 生成所有代码和测试用例
- **测试执行**: Claude AI 协助自动化测试执行和验证
- **测试位置**: `/Users/weichen/Documents/testClass`

### 1.2 Claude AI 辅助测试目标
确保团队知识库管理工具在macOS 11.7.10单机环境下功能完整、性能稳定、用户体验良好，通过Claude AI辅助实现高效的自动化测试生成和执行。

### 1.3 单机测试范围
本测试计划覆盖以下方面：
- **功能测试**：Claude生成测试用例，验证所有功能需求
- **本地性能测试**：确保在macOS环境下的性能表现
- **安全测试**：Claude协助验证系统安全防护机制
- **macOS兼容性测试**：确保在macOS 11.7.10上的完美兼容
- **用户体验测试**：Claude辅助界面和交互验证

### 1.4 Claude AI 自动测试策略
采用**Claude AI 全程协助的智能测试**策略：
- **测试用例生成**：Claude根据需求自动生成完整测试用例
- **测试代码生成**：Claude生成单元测试、集成测试、E2E测试代码
- **测试执行指导**：Claude指导测试执行和结果验证
- **问题诊断**：Claude协助分析测试失败原因和解决方案

### 1.5 macOS单机测试环境
- **开发测试环境**：本地macOS开发机器 (`~/Documents/testClass`)
- **数据库测试**：本地SQLite数据库文件
- **文件存储测试**：本地文件系统 (`uploads/` 目录)
- **网络测试**：本地localhost环境 (http://localhost:3000, http://localhost:8000)

## 2. Claude AI 测试协助模式

### 2.1 Claude AI 测试角色定义
- **测试架构师**：设计测试框架和策略
- **测试用例设计师**：根据需求生成详细测试用例
- **测试代码生成器**：生成各层级的自动化测试代码
- **测试执行顾问**：指导测试执行和结果分析
- **问题诊断专家**：分析测试失败和系统问题

### 2.2 单人开发测试流程
```
需求分析 → Claude生成测试用例 → Claude生成测试代码 → 本地自动执行 → Claude分析结果 → 问题修复 → 回归验证
    ↑                                                                                            ↓
    └────────────────────────── Claude持续优化测试策略 ←──────────────────────────────────────────┘
```

### 2.3 Claude AI 测试协作方式

#### 测试用例生成请求模式
1. **明确测试需求**：详细描述功能和测试场景
2. **提供技术上下文**：给出代码结构和技术栈信息
3. **指定测试类型**：单元测试、集成测试、E2E测试
4. **验证测试结果**：执行生成的测试并反馈结果

#### 测试问题解决模式
- **失败分析**：提供测试失败信息获取解决方案
- **覆盖率优化**：询问如何提高测试覆盖率
- **性能测试**：获取性能测试策略和实现
- **最佳实践**：学习测试设计最佳实践

## 3. macOS 单机测试分层策略

### 3.1 Claude AI 生成的测试金字塔

```
                    E2E Tests (10%)
                  ┌─────────────────┐
                  │  Claude生成      │
                  │  用户流程测试    │
                  └─────────────────┘
                Integration Tests (20%)
              ┌─────────────────────────┐
              │  Claude生成 API测试      │
              │  数据库集成测试          │
              └─────────────────────────┘
            Unit Tests (70%)
          ┌───────────────────────────────┐
          │  Claude生成 组件测试          │
          │  函数测试 业务逻辑测试        │
          └───────────────────────────────┘
```

### 3.2 测试覆盖率目标 (macOS单机版)
- **单元测试覆盖率**: > 85% (Claude生成高质量测试)
- **集成测试覆盖率**: > 75% (重点API和数据库测试)
- **端到端测试覆盖率**: > 60% (核心用户流程)
- **需求覆盖率**: 100% (确保所有功能点测试)

## 4. Claude AI 生成的测试代码示例

### 4.1 前端单元测试 (Claude生成)

#### React组件测试
```javascript
// Claude生成的DocumentCard组件测试
import { render, screen, fireEvent } from '@testing-library/react';
import { DocumentCard } from '../components/DocumentCard';
import { AuthContext } from '../contexts/AuthContext';

describe('DocumentCard Component', () => {
  const mockDocument = {
    id: 1,
    title: '测试文档',
    description: '这是一个测试文档',
    fileName: 'test.pdf',
    fileSize: 1024000,
    createdAt: '2025-09-13T10:00:00Z',
    tags: ['技术', '文档']
  };

  const mockAuthContext = {
    user: { id: 1, role: 'editor' },
    isAuthenticated: true
  };

  test('应该正确渲染文档信息', () => {
    render(
      <AuthContext.Provider value={mockAuthContext}>
        <DocumentCard document={mockDocument} />
      </AuthContext.Provider>
    );

    expect(screen.getByText('测试文档')).toBeInTheDocument();
    expect(screen.getByText('这是一个测试文档')).toBeInTheDocument();
    expect(screen.getByText('1.0 MB')).toBeInTheDocument();
  });

  test('应该显示文档标签', () => {
    render(
      <AuthContext.Provider value={mockAuthContext}>
        <DocumentCard document={mockDocument} />
      </AuthContext.Provider>
    );

    expect(screen.getByText('技术')).toBeInTheDocument();
    expect(screen.getByText('文档')).toBeInTheDocument();
  });

  test('下载按钮点击应该触发下载', () => {
    const mockDownload = jest.fn();
    render(
      <AuthContext.Provider value={mockAuthContext}>
        <DocumentCard document={mockDocument} onDownload={mockDownload} />
      </AuthContext.Provider>
    );

    fireEvent.click(screen.getByTestId('download-button'));
    expect(mockDownload).toHaveBeenCalledWith(1);
  });

  test('非编辑权限用户不应显示删除按钮', () => {
    const viewerContext = {
      user: { id: 2, role: 'viewer' },
      isAuthenticated: true
    };

    render(
      <AuthContext.Provider value={viewerContext}>
        <DocumentCard document={mockDocument} />
      </AuthContext.Provider>
    );

    expect(screen.queryByTestId('delete-button')).not.toBeInTheDocument();
  });
});
```

#### 前端Hook测试
```javascript
// Claude生成的useDocuments Hook测试
import { renderHook, act } from '@testing-library/react';
import { useDocuments } from '../hooks/useDocuments';
import * as documentApi from '../services/documentApi';

jest.mock('../services/documentApi');

describe('useDocuments Hook', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('应该正确获取文档列表', async () => {
    const mockDocuments = [
      { id: 1, title: '文档1' },
      { id: 2, title: '文档2' }
    ];
    
    documentApi.getDocuments.mockResolvedValue({
      data: mockDocuments,
      total: 2
    });

    const { result } = renderHook(() => useDocuments());

    expect(result.current.loading).toBe(true);
    expect(result.current.documents).toEqual([]);

    await act(async () => {
      await result.current.fetchDocuments();
    });

    expect(result.current.loading).toBe(false);
    expect(result.current.documents).toEqual(mockDocuments);
    expect(result.current.total).toBe(2);
  });

  test('应该处理获取文档失败', async () => {
    const mockError = new Error('Network Error');
    documentApi.getDocuments.mockRejectedValue(mockError);

    const { result } = renderHook(() => useDocuments());

    await act(async () => {
      await result.current.fetchDocuments();
    });

    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBe(mockError.message);
    expect(result.current.documents).toEqual([]);
  });

  test('搜索功能应该正常工作', async () => {
    const mockSearchResults = [
      { id: 1, title: '搜索结果1' }
    ];

    documentApi.searchDocuments.mockResolvedValue({
      data: mockSearchResults,
      total: 1
    });

    const { result } = renderHook(() => useDocuments());

    await act(async () => {
      await result.current.searchDocuments('test query');
    });

    expect(documentApi.searchDocuments).toHaveBeenCalledWith('test query');
    expect(result.current.documents).toEqual(mockSearchResults);
  });
});
```

### 4.2 后端单元测试 (Claude生成)

#### 控制器测试
```javascript
// Claude生成的DocumentController测试
import request from 'supertest';
import app from '../../app';
import { DocumentService } from '../../services/DocumentService';
import { AuthMiddleware } from '../../middleware/AuthMiddleware';

jest.mock('../../services/DocumentService');
jest.mock('../../middleware/AuthMiddleware');

describe('DocumentController', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    AuthMiddleware.verifyToken.mockImplementation((req, res, next) => {
      req.user = { id: 1, role: 'editor' };
      next();
    });
  });

  describe('GET /api/v1/documents', () => {
    test('应该返回文档列表', async () => {
      const mockDocuments = [
        { id: 1, title: '文档1', createdBy: 1 },
        { id: 2, title: '文档2', createdBy: 1 }
      ];

      DocumentService.prototype.getDocuments.mockResolvedValue({
        documents: mockDocuments,
        total: 2,
        page: 1,
        limit: 10
      });

      const response = await request(app)
        .get('/api/v1/documents')
        .set('Authorization', 'Bearer valid_token');

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.documents).toEqual(mockDocuments);
      expect(response.body.data.total).toBe(2);
    });

    test('应该支持分页查询', async () => {
      DocumentService.prototype.getDocuments.mockResolvedValue({
        documents: [],
        total: 50,
        page: 2,
        limit: 20
      });

      const response = await request(app)
        .get('/api/v1/documents?page=2&limit=20')
        .set('Authorization', 'Bearer valid_token');

      expect(response.status).toBe(200);
      expect(DocumentService.prototype.getDocuments).toHaveBeenCalledWith({
        page: 2,
        limit: 20,
        userId: 1
      });
    });

    test('无认证应该返回401', async () => {
      const response = await request(app)
        .get('/api/v1/documents');

      expect(response.status).toBe(401);
    });
  });

  describe('POST /api/v1/documents', () => {
    test('应该成功上传文档', async () => {
      const mockDocument = {
        id: 1,
        title: '新文档',
        fileName: 'test.pdf',
        filePath: '/uploads/test.pdf'
      };

      DocumentService.prototype.createDocument.mockResolvedValue(mockDocument);

      const response = await request(app)
        .post('/api/v1/documents')
        .set('Authorization', 'Bearer valid_token')
        .attach('file', Buffer.from('test file'), 'test.pdf')
        .field('title', '新文档')
        .field('description', '测试文档描述');

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toEqual(mockDocument);
    });

    test('缺少文件应该返回400', async () => {
      const response = await request(app)
        .post('/api/v1/documents')
        .set('Authorization', 'Bearer valid_token')
        .field('title', '新文档');

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('文件');
    });
  });
});
```

#### 服务层测试
```javascript
// Claude生成的DocumentService测试
import { DocumentService } from '../../services/DocumentService';
import { DatabaseManager } from '../../database/DatabaseManager';
import { FileManager } from '../../utils/FileManager';
import path from 'path';
import fs from 'fs/promises';

jest.mock('../../database/DatabaseManager');
jest.mock('../../utils/FileManager');

describe('DocumentService', () => {
  let documentService;
  let mockDb;

  beforeEach(() => {
    mockDb = {
      get: jest.fn(),
      all: jest.fn(),
      run: jest.fn()
    };
    DatabaseManager.getInstance.mockReturnValue(mockDb);
    documentService = new DocumentService();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getDocuments', () => {
    test('应该返回用户文档列表', async () => {
      const mockDocuments = [
        {
          id: 1,
          title: '文档1',
          description: '描述1',
          fileName: 'doc1.pdf',
          createdBy: 1,
          createdAt: '2025-09-13T10:00:00Z'
        }
      ];

      mockDb.all.mockResolvedValue(mockDocuments);
      mockDb.get.mockResolvedValue({ count: 1 });

      const result = await documentService.getDocuments({
        page: 1,
        limit: 10,
        userId: 1
      });

      expect(result.documents).toEqual(mockDocuments);
      expect(result.total).toBe(1);
      expect(result.page).toBe(1);
      expect(result.limit).toBe(10);
    });

    test('应该支持搜索功能', async () => {
      const searchQuery = '技术文档';
      mockDb.all.mockResolvedValue([]);
      mockDb.get.mockResolvedValue({ count: 0 });

      await documentService.getDocuments({
        page: 1,
        limit: 10,
        userId: 1,
        search: searchQuery
      });

      expect(mockDb.all).toHaveBeenCalledWith(
        expect.stringContaining('WHERE'),
        expect.arrayContaining([`%${searchQuery}%`])
      );
    });
  });

  describe('createDocument', () => {
    test('应该成功创建文档', async () => {
      const fileData = {
        originalname: 'test.pdf',
        buffer: Buffer.from('test'),
        mimetype: 'application/pdf',
        size: 1024
      };

      const documentData = {
        title: '测试文档',
        description: '测试描述',
        tags: ['技术', '文档']
      };

      const userId = 1;
      const savedFilePath = '/uploads/test_123456.pdf';

      FileManager.saveFile.mockResolvedValue(savedFilePath);
      mockDb.run.mockResolvedValue({ lastID: 1 });
      mockDb.get.mockResolvedValue({
        id: 1,
        title: '测试文档',
        fileName: 'test_123456.pdf',
        filePath: savedFilePath
      });

      const result = await documentService.createDocument(
        fileData,
        documentData,
        userId
      );

      expect(FileManager.saveFile).toHaveBeenCalledWith(
        fileData,
        expect.stringContaining('uploads')
      );
      expect(result.id).toBe(1);
      expect(result.title).toBe('测试文档');
    });

    test('文件保存失败应该抛出错误', async () => {
      const fileData = { originalname: 'test.pdf' };
      const documentData = { title: '测试文档' };

      FileManager.saveFile.mockRejectedValue(new Error('文件保存失败'));

      await expect(
        documentService.createDocument(fileData, documentData, 1)
      ).rejects.toThrow('文件保存失败');
    });
  });

  describe('deleteDocument', () => {
    test('应该软删除文档', async () => {
      mockDb.get.mockResolvedValue({
        id: 1,
        createdBy: 1,
        filePath: '/uploads/test.pdf'
      });
      mockDb.run.mockResolvedValue({ changes: 1 });

      const result = await documentService.deleteDocument(1, 1);

      expect(mockDb.run).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE documents SET deleted_at'),
        expect.any(Array)
      );
      expect(result).toBe(true);
    });

    test('删除他人文档应该抛出错误', async () => {
      mockDb.get.mockResolvedValue({
        id: 1,
        createdBy: 2
      });

      await expect(
        documentService.deleteDocument(1, 1)
      ).rejects.toThrow('权限不足');
    });
  });
});
```

### 4.3 集成测试 (Claude生成)

#### API集成测试
```javascript
// Claude生成的API集成测试
import request from 'supertest';
import app from '../../app';
import { DatabaseManager } from '../../database/DatabaseManager';
import path from 'path';
import fs from 'fs/promises';

describe('API Integration Tests', () => {
  let authToken;
  let userId;

  beforeAll(async () => {
    // 初始化测试数据库
    await DatabaseManager.initializeTestDatabase();
    
    // 创建测试用户并获取认证token
    const registerResponse = await request(app)
      .post('/api/v1/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'test123456',
        fullName: '测试用户'
      });

    expect(registerResponse.status).toBe(201);

    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        username: 'testuser',
        password: 'test123456'
      });

    expect(loginResponse.status).toBe(200);
    authToken = loginResponse.body.data.token;
    userId = loginResponse.body.data.user.id;
  });

  afterAll(async () => {
    // 清理测试数据库
    await DatabaseManager.clearTestDatabase();
  });

  describe('完整文档管理流程', () => {
    let documentId;

    test('上传文档 → 获取列表 → 查看详情 → 下载 → 删除', async () => {
      // 1. 上传文档
      const testFilePath = path.join(__dirname, '../fixtures/test.pdf');
      const uploadResponse = await request(app)
        .post('/api/v1/documents')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', testFilePath)
        .field('title', '集成测试文档')
        .field('description', '这是集成测试上传的文档')
        .field('tags', JSON.stringify(['测试', '集成']));

      expect(uploadResponse.status).toBe(201);
      expect(uploadResponse.body.success).toBe(true);
      documentId = uploadResponse.body.data.id;

      // 2. 获取文档列表，验证文档存在
      const listResponse = await request(app)
        .get('/api/v1/documents')
        .set('Authorization', `Bearer ${authToken}`);

      expect(listResponse.status).toBe(200);
      expect(listResponse.body.data.documents).toHaveLength(1);
      expect(listResponse.body.data.documents[0].title).toBe('集成测试文档');

      // 3. 查看文档详情
      const detailResponse = await request(app)
        .get(`/api/v1/documents/${documentId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(detailResponse.status).toBe(200);
      expect(detailResponse.body.data.title).toBe('集成测试文档');
      expect(detailResponse.body.data.description).toBe('这是集成测试上传的文档');

      // 4. 下载文档
      const downloadResponse = await request(app)
        .get(`/api/v1/documents/${documentId}/download`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(downloadResponse.status).toBe(200);
      expect(downloadResponse.headers['content-type']).toBe('application/pdf');

      // 5. 删除文档
      const deleteResponse = await request(app)
        .delete(`/api/v1/documents/${documentId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(deleteResponse.status).toBe(200);

      // 6. 验证删除后获取列表为空
      const emptyListResponse = await request(app)
        .get('/api/v1/documents')
        .set('Authorization', `Bearer ${authToken}`);

      expect(emptyListResponse.body.data.documents).toHaveLength(0);
    });
  });

  describe('搜索和标签集成测试', () => {
    beforeEach(async () => {
      // 创建测试文档
      await request(app)
        .post('/api/v1/documents')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', Buffer.from('test content'), 'tech_doc.pdf')
        .field('title', '技术文档')
        .field('description', '这是一个技术相关的文档')
        .field('tags', JSON.stringify(['技术', 'API']));

      await request(app)
        .post('/api/v1/documents')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', Buffer.from('product content'), 'product_doc.pdf')
        .field('title', '产品文档')
        .field('description', '这是一个产品相关的文档')
        .field('tags', JSON.stringify(['产品', '需求']));
    });

    test('搜索功能应该正常工作', async () => {
      // 搜索标题关键词
      const searchResponse = await request(app)
        .get('/api/v1/search?q=技术')
        .set('Authorization', `Bearer ${authToken}`);

      expect(searchResponse.status).toBe(200);
      expect(searchResponse.body.data.documents).toHaveLength(1);
      expect(searchResponse.body.data.documents[0].title).toBe('技术文档');

      // 搜索描述关键词
      const descSearchResponse = await request(app)
        .get('/api/v1/search?q=产品相关')
        .set('Authorization', `Bearer ${authToken}`);

      expect(descSearchResponse.status).toBe(200);
      expect(descSearchResponse.body.data.documents).toHaveLength(1);
      expect(descSearchResponse.body.data.documents[0].title).toBe('产品文档');
    });

    test('标签筛选应该正常工作', async () => {
      // 按标签筛选
      const tagFilterResponse = await request(app)
        .get('/api/v1/documents?tags=技术')
        .set('Authorization', `Bearer ${authToken}`);

      expect(tagFilterResponse.status).toBe(200);
      expect(tagFilterResponse.body.data.documents).toHaveLength(1);
      expect(tagFilterResponse.body.data.documents[0].title).toBe('技术文档');
    });

    test('标签管理功能', async () => {
      // 获取所有标签
      const tagsResponse = await request(app)
        .get('/api/v1/tags')
        .set('Authorization', `Bearer ${authToken}`);

      expect(tagsResponse.status).toBe(200);
      expect(tagsResponse.body.data).toContainEqual(
        expect.objectContaining({ name: '技术' })
      );
      expect(tagsResponse.body.data).toContainEqual(
        expect.objectContaining({ name: '产品' })
      );
    });
  });
});
```

### 4.4 端到端测试 (Claude生成)

#### Playwright E2E测试
```javascript
// Claude生成的E2E测试
import { test, expect } from '@playwright/test';
import path from 'path';

test.describe('知识库管理工具 E2E测试', () => {
  let page;

  test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();
    
    // 清理测试数据
    await page.goto('http://localhost:3000/test/cleanup');
    
    // 访问登录页面
    await page.goto('http://localhost:3000/login');
  });

  test.afterEach(async () => {
    await page.close();
  });

  test('完整用户流程：注册 → 登录 → 上传 → 搜索 → 下载', async () => {
    // 1. 用户注册
    await page.click('[data-testid="register-link"]');
    await page.fill('[data-testid="register-username"]', 'e2euser');
    await page.fill('[data-testid="register-email"]', 'e2e@test.com');
    await page.fill('[data-testid="register-password"]', 'password123');
    await page.fill('[data-testid="register-fullname"]', 'E2E测试用户');
    await page.click('[data-testid="register-submit"]');

    // 验证注册成功提示
    await expect(page.locator('[data-testid="success-message"]')).toContainText('注册成功');

    // 2. 用户登录
    await page.fill('[data-testid="login-username"]', 'e2euser');
    await page.fill('[data-testid="login-password"]', 'password123');
    await page.click('[data-testid="login-submit"]');

    // 验证登录成功，跳转到仪表盘
    await expect(page).toHaveURL('http://localhost:3000/dashboard');
    await expect(page.locator('[data-testid="welcome-message"]')).toContainText('E2E测试用户');

    // 3. 上传文档
    await page.click('[data-testid="upload-button"]');
    
    // 选择文件
    const fileInput = page.locator('[data-testid="file-input"]');
    await fileInput.setInputFiles(path.join(__dirname, '../fixtures/sample.pdf'));
    
    // 填写文档信息
    await page.fill('[data-testid="document-title"]', 'E2E测试文档');
    await page.fill('[data-testid="document-description"]', '这是E2E测试上传的文档');
    
    // 添加标签
    await page.click('[data-testid="tag-input"]');
    await page.keyboard.type('测试');
    await page.keyboard.press('Enter');
    await page.keyboard.type('E2E');
    await page.keyboard.press('Enter');
    
    // 提交上传
    await page.click('[data-testid="upload-submit"]');
    
    // 验证上传成功
    await expect(page.locator('[data-testid="upload-success"]')).toBeVisible();
    await expect(page.locator('[data-testid="document-list"]')).toContainText('E2E测试文档');

    // 4. 搜索文档
    await page.fill('[data-testid="search-input"]', 'E2E测试');
    await page.press('[data-testid="search-input"]', 'Enter');
    
    // 验证搜索结果
    await expect(page.locator('[data-testid="search-results"]')).toContainText('E2E测试文档');
    await expect(page.locator('[data-testid="search-count"]')).toContainText('找到 1 个文档');

    // 5. 查看文档详情
    await page.click('[data-testid="document-card"]:has-text("E2E测试文档")');
    await expect(page.locator('[data-testid="document-detail-title"]')).toContainText('E2E测试文档');
    await expect(page.locator('[data-testid="document-detail-description"]')).toContainText('这是E2E测试上传的文档');
    
    // 验证标签显示
    await expect(page.locator('[data-testid="document-tags"]')).toContainText('测试');
    await expect(page.locator('[data-testid="document-tags"]')).toContainText('E2E');

    // 6. 下载文档
    const downloadPromise = page.waitForEvent('download');
    await page.click('[data-testid="download-button"]');
    const download = await downloadPromise;
    
    // 验证下载文件名
    expect(download.suggestedFilename()).toContain('sample.pdf');
  });

  test('高级搜索功能测试', async () => {
    // 先登录
    await page.fill('[data-testid="login-username"]', 'admin');
    await page.fill('[data-testid="login-password"]', 'admin123');
    await page.click('[data-testid="login-submit"]');

    // 访问高级搜索
    await page.click('[data-testid="advanced-search-button"]');
    
    // 设置搜索条件
    await page.fill('[data-testid="search-title"]', '技术');
    await page.selectOption('[data-testid="search-filetype"]', 'pdf');
    await page.click('[data-testid="search-tag"]:has-text("技术")');
    
    // 设置时间范围
    await page.fill('[data-testid="search-date-from"]', '2025-09-01');
    await page.fill('[data-testid="search-date-to"]', '2025-09-30');
    
    // 执行搜索
    await page.click('[data-testid="advanced-search-submit"]');
    
    // 验证搜索结果
    await expect(page.locator('[data-testid="search-results-container"]')).toBeVisible();
    
    // 验证筛选条件显示
    await expect(page.locator('[data-testid="active-filters"]')).toContainText('文件类型: PDF');
    await expect(page.locator('[data-testid="active-filters"]')).toContainText('标签: 技术');
  });

  test('响应式设计测试', async () => {
    // 登录
    await page.fill('[data-testid="login-username"]', 'admin');
    await page.fill('[data-testid="login-password"]', 'admin123');
    await page.click('[data-testid="login-submit"]');

    // 测试桌面视图
    await page.setViewportSize({ width: 1920, height: 1080 });
    await expect(page.locator('[data-testid="sidebar"]')).toBeVisible();
    await expect(page.locator('[data-testid="main-content"]')).toHaveCSS('margin-left', '240px');

    // 测试平板视图
    await page.setViewportSize({ width: 768, height: 1024 });
    await expect(page.locator('[data-testid="mobile-menu-button"]')).toBeVisible();
    
    // 测试手机视图
    await page.setViewportSize({ width: 375, height: 667 });
    await expect(page.locator('[data-testid="mobile-header"]')).toBeVisible();
    await expect(page.locator('[data-testid="document-grid"]')).toHaveCSS('grid-template-columns', '1fr');
  });

  test('权限控制测试', async () => {
    // 以查看者身份登录
    await page.fill('[data-testid="login-username"]', 'viewer');
    await page.fill('[data-testid="login-password"]', 'viewer123');
    await page.click('[data-testid="login-submit"]');

    // 验证查看者权限限制
    await expect(page.locator('[data-testid="upload-button"]')).not.toBeVisible();
    await expect(page.locator('[data-testid="delete-button"]')).not.toBeVisible();
    
    // 可以查看和下载文档
    await expect(page.locator('[data-testid="document-list"]')).toBeVisible();
    await expect(page.locator('[data-testid="download-button"]')).toBeVisible();

    // 登出并以编辑者身份登录
    await page.click('[data-testid="user-menu"]');
    await page.click('[data-testid="logout-button"]');
    
    await page.fill('[data-testid="login-username"]', 'editor');
    await page.fill('[data-testid="login-password"]', 'editor123');
    await page.click('[data-testid="login-submit"]');

    // 验证编辑者权限
    await expect(page.locator('[data-testid="upload-button"]')).toBeVisible();
    await expect(page.locator('[data-testid="edit-button"]')).toBeVisible();
  });
});
```

## 5. macOS 单机性能测试 (Claude协助)

### 5.1 本地性能指标

#### macOS环境性能目标
- **页面加载时间**: < 2秒 (本地环境)
- **API响应时间**: < 1秒 (localhost)
- **搜索响应时间**: < 1秒 (SQLite查询)
- **文件上传时间**: < 10秒 (10MB文件，本地存储)
- **内存使用**: < 200MB (Node.js进程)
- **CPU使用**: < 50% (正常操作时)

### 5.2 Claude生成的性能测试脚本

#### 前端性能测试
```javascript
// Claude生成的前端性能测试
import { test, expect } from '@playwright/test';

test.describe('前端性能测试', () => {
  test('页面加载性能检查', async ({ page }) => {
    // 启用性能监控
    await page.goto('http://localhost:3000', { waitUntil: 'networkidle' });
    
    // 获取性能指标
    const performanceTimings = await page.evaluate(() => {
      const perfData = performance.getEntriesByType('navigation')[0];
      return {
        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
        loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
        firstPaint: performance.getEntriesByType('paint')[0]?.startTime,
        firstContentfulPaint: performance.getEntriesByType('paint')[1]?.startTime,
      };
    });

    // 验证性能指标
    expect(performanceTimings.domContentLoaded).toBeLessThan(1000); // 1秒内DOM加载完成
    expect(performanceTimings.loadComplete).toBeLessThan(2000); // 2秒内页面完全加载
    expect(performanceTimings.firstPaint).toBeLessThan(500); // 500ms内首次绘制
    expect(performanceTimings.firstContentfulPaint).toBeLessThan(800); // 800ms内首次内容绘制
  });

  test('文档列表渲染性能', async ({ page }) => {
    await page.goto('http://localhost:3000/dashboard');
    
    // 测量渲染时间
    const renderTime = await page.evaluate(() => {
      const start = performance.now();
      
      // 触发大列表渲染
      const event = new CustomEvent('loadDocuments', { 
        detail: { count: 1000 } 
      });
      document.dispatchEvent(event);
      
      // 等待渲染完成
      return new Promise(resolve => {
        requestAnimationFrame(() => {
          const end = performance.now();
          resolve(end - start);
        });
      });
    });

    expect(renderTime).toBeLessThan(100); // 100ms内完成渲染
  });

  test('搜索响应性能', async ({ page }) => {
    await page.goto('http://localhost:3000/dashboard');
    
    const searchInput = page.locator('[data-testid="search-input"]');
    
    // 测量搜索响应时间
    const searchTime = await page.evaluate(async () => {
      const searchInput = document.querySelector('[data-testid="search-input"]');
      const start = performance.now();
      
      // 模拟输入搜索关键词
      searchInput.value = 'test query';
      searchInput.dispatchEvent(new Event('input', { bubbles: true }));
      
      // 等待搜索完成
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const end = performance.now();
      return end - start;
    });

    expect(searchTime).toBeLessThan(1000); // 1秒内返回搜索结果
  });
});
```

#### 后端性能测试
```javascript
// Claude生成的后端性能测试
import autocannon from 'autocannon';
import { DatabaseManager } from '../database/DatabaseManager';

describe('后端性能测试', () => {
  beforeAll(async () => {
    await DatabaseManager.initializeTestDatabase();
    // 插入测试数据
    await DatabaseManager.seedTestData(1000); // 1000条文档记录
  });

  afterAll(async () => {
    await DatabaseManager.clearTestDatabase();
  });

  test('API接口性能测试', async () => {
    // 测试文档列表API性能
    const listResult = await autocannon({
      url: 'http://localhost:8000/api/v1/documents',
      headers: {
        'Authorization': 'Bearer test_token'
      },
      connections: 10,
      duration: 10,
      timeout: 5
    });

    expect(listResult.requests.average).toBeGreaterThan(100); // 平均QPS > 100
    expect(listResult.latency.average).toBeLessThan(100); // 平均延迟 < 100ms

    // 测试搜索API性能
    const searchResult = await autocannon({
      url: 'http://localhost:8000/api/v1/search?q=test',
      headers: {
        'Authorization': 'Bearer test_token'
      },
      connections: 5,
      duration: 10
    });

    expect(searchResult.latency.average).toBeLessThan(200); // 搜索延迟 < 200ms
  });

  test('数据库查询性能', async () => {
    const db = DatabaseManager.getInstance();
    
    // 测试简单查询性能
    const simpleQueryStart = performance.now();
    await db.all('SELECT * FROM documents LIMIT 100');
    const simpleQueryTime = performance.now() - simpleQueryStart;
    
    expect(simpleQueryTime).toBeLessThan(50); // 简单查询 < 50ms

    // 测试复杂查询性能（搜索）
    const searchQueryStart = performance.now();
    await db.all(`
      SELECT d.*, GROUP_CONCAT(t.name) as tags
      FROM documents d
      LEFT JOIN document_tags dt ON d.id = dt.document_id
      LEFT JOIN tags t ON dt.tag_id = t.id
      WHERE d.title LIKE '%test%' OR d.description LIKE '%test%'
      GROUP BY d.id
      LIMIT 50
    `, ['%test%', '%test%']);
    const searchQueryTime = performance.now() - searchQueryStart;
    
    expect(searchQueryTime).toBeLessThan(100); // 搜索查询 < 100ms
  });

  test('文件操作性能', async () => {
    const fs = require('fs/promises');
    const path = require('path');
    
    // 测试文件读取性能
    const testFilePath = path.join(__dirname, '../fixtures/large_file.pdf');
    const readStart = performance.now();
    const fileData = await fs.readFile(testFilePath);
    const readTime = performance.now() - readStart;
    
    expect(readTime).toBeLessThan(500); // 文件读取 < 500ms
    
    // 测试文件写入性能
    const writeStart = performance.now();
    const writePath = path.join(__dirname, '../temp/test_write.pdf');
    await fs.writeFile(writePath, fileData);
    const writeTime = performance.now() - writeStart;
    
    expect(writeTime).toBeLessThan(300); // 文件写入 < 300ms
    
    // 清理测试文件
    await fs.unlink(writePath);
  });
});
```

## 6. macOS 兼容性和安全测试

### 6.1 macOS 兼容性测试

#### 系统兼容性检查
```javascript
// Claude生成的macOS兼容性测试
describe('macOS 11.7.10 兼容性测试', () => {
  test('Node.js版本兼容性', () => {
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.split('.')[0].substring(1));
    
    expect(majorVersion).toBeGreaterThanOrEqual(16); // 支持Node.js 16+
  });

  test('文件路径处理兼容性', async () => {
    const path = require('path');
    const fs = require('fs/promises');
    
    // 测试中文路径支持
    const chinesePath = path.join(__dirname, '../temp/中文文档.txt');
    await fs.writeFile(chinesePath, '测试内容');
    
    const content = await fs.readFile(chinesePath, 'utf8');
    expect(content).toBe('测试内容');
    
    await fs.unlink(chinesePath);
  });

  test('SQLite在macOS上的兼容性', async () => {
    const Database = require('better-sqlite3');
    const path = require('path');
    
    const dbPath = path.join(__dirname, '../temp/test_macos.db');
    const db = new Database(dbPath);
    
    // 创建测试表
    db.exec(`
      CREATE TABLE test_table (
        id INTEGER PRIMARY KEY,
        name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // 插入测试数据
    const insert = db.prepare('INSERT INTO test_table (name) VALUES (?)');
    insert.run('测试数据');
    
    // 查询数据
    const rows = db.prepare('SELECT * FROM test_table').all();
    expect(rows).toHaveLength(1);
    expect(rows[0].name).toBe('测试数据');
    
    db.close();
    
    // 清理
    const fs = require('fs');
    fs.unlinkSync(dbPath);
  });

  test('macOS权限和安全检查', async () => {
    const fs = require('fs/promises');
    const path = require('path');
    
    // 检查uploads目录权限
    const uploadsDir = path.join(__dirname, '../../uploads');
    
    try {
      await fs.access(uploadsDir, fs.constants.R_OK | fs.constants.W_OK);
    } catch (error) {
      // 如果目录不存在，创建它
      await fs.mkdir(uploadsDir, { recursive: true });
    }
    
    // 测试文件读写权限
    const testFile = path.join(uploadsDir, 'permission_test.txt');
    await fs.writeFile(testFile, 'permission test');
    const content = await fs.readFile(testFile, 'utf8');
    
    expect(content).toBe('permission test');
    
    await fs.unlink(testFile);
  });
});
```

### 6.2 安全测试 (Claude协助)

```javascript
// Claude生成的安全测试
describe('安全测试', () => {
  test('JWT Token安全性', () => {
    const jwt = require('jsonwebtoken');
    const secret = process.env.JWT_SECRET || 'test-secret';
    
    // 测试Token生成和验证
    const payload = { userId: 1, role: 'user' };
    const token = jwt.sign(payload, secret, { expiresIn: '1h' });
    
    const decoded = jwt.verify(token, secret);
    expect(decoded.userId).toBe(1);
    expect(decoded.role).toBe('user');
  });

  test('密码加密安全性', async () => {
    const bcrypt = require('bcryptjs');
    
    const password = 'testPassword123';
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // 验证密码不是明文存储
    expect(hashedPassword).not.toBe(password);
    expect(hashedPassword.length).toBeGreaterThan(50);
    
    // 验证密码校验功能
    const isValid = await bcrypt.compare(password, hashedPassword);
    expect(isValid).toBe(true);
    
    const isInvalid = await bcrypt.compare('wrongPassword', hashedPassword);
    expect(isInvalid).toBe(false);
  });

  test('文件上传安全检查', () => {
    const path = require('path');
    
    // 测试文件类型验证
    const allowedTypes = ['.pdf', '.doc', '.docx', '.txt', '.png', '.jpg'];
    
    const testFiles = [
      'document.pdf',
      'image.jpg',
      'script.js',  // 不安全
      'executable.exe',  // 不安全
      '../../../etc/passwd'  // 路径遍历攻击
    ];
    
    testFiles.forEach(filename => {
      const ext = path.extname(filename).toLowerCase();
      const isValid = allowedTypes.includes(ext) && !filename.includes('..');
      
      if (filename === 'document.pdf' || filename === 'image.jpg') {
        expect(isValid).toBe(true);
      } else {
        expect(isValid).toBe(false);
      }
    });
  });

  test('SQL注入防护', async () => {
    const { DatabaseManager } = require('../database/DatabaseManager');
    const db = DatabaseManager.getInstance();
    
    // 测试参数化查询
    const maliciousInput = "'; DROP TABLE documents; --";
    
    try {
      // 使用参数化查询，应该安全
      const result = await db.all(
        'SELECT * FROM documents WHERE title = ?',
        [maliciousInput]
      );
      
      // 查询应该成功执行（返回空结果），而不是破坏数据库
      expect(Array.isArray(result)).toBe(true);
      
      // 验证documents表仍然存在
      const tableCheck = await db.all(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='documents'"
      );
      expect(tableCheck).toHaveLength(1);
      
    } catch (error) {
      // 如果出错，确保不是因为SQL注入成功
      expect(error.message).not.toContain('no such table: documents');
    }
  });

  test('XSS防护检查', () => {
    const validator = require('validator');
    
    const maliciousInputs = [
      '<script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src="x" onerror="alert(\'XSS\')">',
      '"><script>alert("XSS")</script>'
    ];
    
    maliciousInputs.forEach(input => {
      // 测试HTML实体编码
      const escaped = validator.escape(input);
      expect(escaped).not.toContain('<script>');
      expect(escaped).not.toContain('javascript:');
      expect(escaped).not.toContain('onerror=');
    });
  });
});
```

## 7. Claude AI 测试执行计划

### 7.1 每周测试计划 (与开发计划同步)

#### Week 1: 基础框架测试 (2025.09.13-09.19)
**Claude AI 协助任务**:
- 生成用户认证模块的完整测试套件
- 创建数据库操作的单元测试
- 生成API接口的集成测试
- 设置本地测试环境和CI配置

**测试目标**:
- 单元测试覆盖率达到80%
- 所有认证API集成测试通过
- 数据库CRUD操作验证完成

#### Week 2: 核心功能测试 (2025.09.20-09.26)
**Claude AI 协助任务**:
- 生成文档上传功能的完整测试
- 创建文件处理和存储的测试用例
- 生成前端组件的渲染测试
- 设置端到端测试框架

**测试目标**:
- 文档管理模块测试覆盖率90%
- 文件上传下载功能验证完成
- 前端界面交互测试通过

#### Week 3: 高级功能测试 (2025.09.27-10.03)
**Claude AI 协助任务**:
- 生成搜索功能的性能测试
- 创建标签系统的完整测试套件
- 生成权限控制的安全测试
- 设置性能监控和报告

**测试目标**:
- 搜索性能达到< 1秒响应
- 标签功能测试覆盖率95%
- 权限控制安全验证通过

#### Week 4: 完整性测试 (2025.10.04-10.10)
**Claude AI 协助任务**:
- 生成完整系统的回归测试
- 创建用户体验的E2E测试场景
- 生成性能优化测试报告
- 设置生产环境验证测试

**测试目标**:
- 所有功能回归测试通过
- 用户流程E2E测试完成
- 性能指标达到预期目标

### 7.2 每日测试执行流程

#### Claude AI 协助的每日测试流程
```bash
# 1. 每日测试开始前咨询Claude
# "请为今天的开发任务生成相应的测试用例"

# 2. 执行Claude生成的测试
npm run test:unit
npm run test:integration  
npm run test:e2e

# 3. 收集测试结果
npm run test:coverage

# 4. 向Claude反馈测试结果
# "以下测试失败，请分析原因并提供解决方案：[错误信息]"

# 5. 应用Claude建议的修复方案
# 修复代码或更新测试

# 6. 重新运行测试验证
npm run test:regression
```

### 7.3 测试自动化工具配置

#### Package.json 测试脚本 (Claude生成)
```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=unit",
    "test:integration": "jest --testPathPattern=integration",
    "test:e2e": "playwright test",
    "test:coverage": "jest --coverage",
    "test:watch": "jest --watch",
    "test:performance": "artillery run performance-test.yml",
    "test:security": "npm audit && snyk test",
    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e",
    "test:regression": "npm run test:all && npm run test:performance"
  }
}
```

## 8. Claude AI 测试报告和分析

### 8.1 每日测试报告模板

```markdown
# 知识库管理工具 - 每日测试报告 (Claude AI 协助)

**日期**: 2025-09-XX  
**测试执行**: Claude AI 生成 + 本地自动化执行  
**报告生成**: Claude AI 协助分析

## 今日测试概况
- **单元测试**: 95/100 通过 (95%)
- **集成测试**: 18/20 通过 (90%)  
- **E2E测试**: 8/10 通过 (80%)
- **覆盖率**: 87% (目标: 85%)

## Claude AI 生成的测试用例
✅ **新增用户注册验证测试** (10个用例)
✅ **文档上传安全检查测试** (8个用例)
🔄 **权限控制边界测试** (5个用例) - 进行中

## 发现的问题
🐛 **[TEST-001]** 文件上传大小限制验证失败
- **Claude分析**: 前端验证与后端不一致
- **建议方案**: 统一前后端文件大小配置
- **状态**: 已修复，等待验证

🐛 **[TEST-002]** 搜索结果分页显示异常  
- **Claude分析**: SQL查询OFFSET计算错误
- **建议方案**: 修正分页算法，添加边界检查
- **状态**: 修复中

## 性能测试结果
- **API响应时间**: 平均456ms (✅ < 1s)
- **页面加载时间**: 平均1.2s (✅ < 2s)  
- **搜索响应**: 平均890ms (✅ < 1s)
- **文件上传**: 5MB文件耗时3.2s (✅ < 10s)

## 明日测试计划
📋 完成权限控制边界测试  
📋 执行Claude生成的标签系统测试  
📋 验证今日修复的问题  
📋 开始高级搜索功能测试

## Claude AI 建议
💡 **测试优化建议**:
- 增加文件类型验证的边界测试
- 补充异常网络情况下的前端测试
- 添加大数据量情况下的性能测试

⚠️ **风险提醒**:
- 搜索功能在数据量增大时可能出现性能问题
- 建议提前准备数据库索引优化方案
```

### 8.2 测试质量度量

#### Claude AI 协助的测试指标分析
```javascript
// Claude生成的测试质量分析脚本
const fs = require('fs');
const path = require('path');

class TestQualityAnalyzer {
  constructor() {
    this.testResults = {};
    this.coverageData = {};
  }

  // 分析测试覆盖率趋势
  analyzeCoverageTrend() {
    const weeklyData = [
      { week: 1, coverage: 75 },
      { week: 2, coverage: 82 },
      { week: 3, coverage: 87 },
      { week: 4, coverage: 91 }
    ];

    const trend = this.calculateTrend(weeklyData);
    
    return {
      currentCoverage: 91,
      targetCoverage: 85,
      trend: trend > 0 ? '上升' : '下降',
      weeklyIncrease: trend,
      status: trend > 0 ? '良好' : '需关注'
    };
  }

  // 分析测试用例质量
  analyzeTestCaseQuality() {
    return {
      totalTestCases: 156,
      claudeGeneratedCases: 134, // 86%
      manualCases: 22,
      passRate: 94.2,
      avgExecutionTime: '2.3s',
      flakyTests: 3, // 不稳定的测试
      maintainabilityScore: 8.7 // 1-10分
    };
  }

  // 分析缺陷发现效率
  analyzeDefectDetection() {
    return {
      totalDefectsFound: 15,
      criticalDefects: 2,
      majorDefects: 6,
      minorDefects: 7,
      defectDetectionRate: 93.3, // 测试发现的缺陷比例
      escapeDefects: 1, // 逃逸到生产的缺陷
      avgFixTime: '4.2 hours'
    };
  }

  // 生成Claude AI测试效果报告
  generateClaudeEffectivenessReport() {
    return {
      testGenerationSpeed: '15 min/module', // Claude生成测试的速度
      testQualityScore: 9.1, // Claude生成测试的质量评分
      coverageImprovement: '+23%', // 相比手工编写的覆盖率提升
      bugDetectionRate: '94%', // Claude测试的缺陷发现率
      falsePositiveRate: '2%', // 误报率
      maintenanceCost: 'Low', // 维护成本
      learningCurve: 'Minimal' // 学习成本
    };
  }

  calculateTrend(data) {
    if (data.length < 2) return 0;
    
    const firstValue = data[0].coverage;
    const lastValue = data[data.length - 1].coverage;
    return ((lastValue - firstValue) / firstValue * 100).toFixed(1);
  }
}

// 使用示例
const analyzer = new TestQualityAnalyzer();
console.log('测试覆盖率趋势:', analyzer.analyzeCoverageTrend());
console.log('测试用例质量:', analyzer.analyzeTestCaseQuality());
console.log('缺陷发现效率:', analyzer.analyzeDefectDetection());
console.log('Claude AI效果:', analyzer.generateClaudeEffectivenessReport());
```

## 9. 测试风险管理 (macOS单机版)

### 9.1 单机测试环境风险

#### 环境风险
1. **macOS系统风险**
   - 风险等级: 低
   - 影响: macOS系统更新可能影响开发环境
   - 缓解措施: 定期备份开发环境，延迟系统更新

2. **本地数据风险**
   - 风险等级: 中
   - 影响: 测试数据可能因系统问题丢失
   - 缓解措施: 每日备份测试数据库，使用Git管理测试脚本

3. **Claude服务依赖风险**
   - 风险等级: 中
   - 影响: Claude服务不可用影响测试用例生成
   - 缓解措施: 预先生成核心测试用例，建立本地测试库

#### 技术风险
1. **测试框架兼容性**
   - 风险等级: 低
   - 影响: 测试工具在macOS上可能出现兼容问题
   - 缓解措施: 选择跨平台测试工具，提前验证兼容性

2. **Node.js版本依赖**
   - 风险等级: 低
   - 影响: Node.js版本更新可能破坏测试环境
   - 缓解措施: 使用nvm管理Node.js版本，锁定项目依赖版本

### 9.2 应急预案

#### Claude AI 服务中断应急
```bash
# 紧急情况下的本地测试执行计划

# 1. 使用预生成的测试用例
npm run test:pre-generated

# 2. 执行核心功能测试
npm run test:core-features

# 3. 手动执行关键路径测试
./scripts/manual-critical-tests.sh

# 4. 生成简化测试报告
npm run test:basic-report
```

#### 测试环境故障恢复
```bash
# 测试环境恢复脚本 (Claude预生成)

#!/bin/bash
echo "开始恢复测试环境..."

# 1. 检查Node.js环境
node --version || echo "警告: Node.js未安装或版本异常"

# 2. 重新安装依赖
rm -rf node_modules package-lock.json
npm install

# 3. 重建测试数据库
npm run db:reset
npm run db:seed

# 4. 验证测试环境
npm run test:smoke

echo "测试环境恢复完成"
```

## 10. 测试完成标准 (macOS单机版)

### 10.1 功能测试完成标准

#### 基础功能验收
- [ ] 用户认证功能测试通过率 100%
- [ ] 文档管理CRUD操作测试通过率 100%
- [ ] 搜索功能在本地环境响应时间 < 1秒
- [ ] 文件上传下载功能在macOS环境正常工作
- [ ] 标签管理功能测试覆盖率 > 90%

#### 质量标准
- [ ] 单元测试覆盖率 ≥ 85%
- [ ] 集成测试覆盖率 ≥ 75%
- [ ] E2E测试覆盖核心用户流程 ≥ 80%
- [ ] Claude生成的测试用例质量评分 ≥ 9.0
- [ ] 所有严重缺陷修复完成

#### 性能标准
- [ ] 本地环境页面加载时间 < 2秒
- [ ] API接口响应时间 < 1秒
- [ ] SQLite数据库查询性能满足要求
- [ ] 内存使用率在正常范围内

### 10.2 macOS兼容性验收

#### 系统兼容性
- [ ] 在macOS 11.7.10上所有功能正常运行
- [ ] 中文文件名和路径处理正确
- [ ] 本地文件存储和访问权限正常
- [ ] SQLite数据库在macOS上性能稳定

#### 开发环境兼容性
- [ ] VS Code开发和调试正常
- [ ] Node.js和npm在macOS上运行稳定
- [ ] 所有测试框架和工具正常工作
- [ ] Git版本控制操作无异常

### 10.3 Claude AI 协助效果验收

#### AI协助质量
- [ ] Claude生成的测试用例准确性 ≥ 95%
- [ ] 测试用例生成速度满足开发节奏
- [ ] 问题诊断和解决方案有效性 ≥ 90%
- [ ] 测试策略优化建议被采纳率 ≥ 80%

#### 开发效率提升
- [ ] 测试开发时间相比传统方式节省 ≥ 60%
- [ ] 测试覆盖率相比手工编写提升 ≥ 20%
- [ ] 缺陷发现率提升 ≥ 15%
- [ ] 测试维护成本降低 ≥ 40%

---

**文档版本**: v2.0 (macOS 11.7.10 Claude AI 自动测试版)  
**创建时间**: 2025-09-13  
**测试平台**: macOS 11.7.10  
**测试模式**: Claude AI 协助的单机自动化测试  
**项目位置**: `/Users/weichen/Documents/testClass`